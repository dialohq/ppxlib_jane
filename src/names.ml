open! Stdppx

module Language_feature_name = struct
  let of_core_type_desc : Shim.Core_type_desc.t -> string = function
    | Ptyp_var _ -> "type variable"
    | Ptyp_tuple _ -> "tuple type"
    | Ptyp_constr _ -> "type constructor"
    | Ptyp_alias _ -> "type alias"
    | Ptyp_variant (_, Open, _) -> "open polymorphic variant type"
    | Ptyp_variant (_, Closed, _) -> "closed polymorphic variant type"
    | Ptyp_any -> "wildcard type"
    | Ptyp_arrow _ -> "arrow type"
    | Ptyp_unboxed_tuple _ -> "unboxed tuple type"
    | Ptyp_object _ -> "object type"
    | Ptyp_class _ -> "class as a type"
    | Ptyp_poly _ -> "explicit polymorphic type"
    | Ptyp_package _ -> "first-class module type"
    | Ptyp_extension _ -> "extension point as a type"
  ;;

  let of_expression_desc : Shim.Expression_desc.t -> string = function
    | Pexp_ident _ -> "variable expression"
    | Pexp_constant (Pconst_char _) -> "character literal expression"
    | Pexp_constant (Pconst_integer _) -> "integer literal expression"
    | Pexp_constant (Pconst_string _) -> "string literal expression"
    | Pexp_constant (Pconst_float _) -> "floating point literal expression"
    | Pexp_let _ -> "let expression"
    | Pexp_function _ -> "function expression"
    | Pexp_apply _ -> "application expression"
    | Pexp_match _ -> "match expression"
    | Pexp_try _ -> "try-with expression"
    | Pexp_tuple _ -> "tuple expression"
    | Pexp_unboxed_tuple _ -> "unboxed tuple expression"
    | Pexp_construct _ -> "variant constructor expression"
    | Pexp_variant _ -> "polymorphic variant constructor expression"
    | Pexp_record (_, None) -> "record expression"
    | Pexp_record (_, Some _) -> "record 'with' expression"
    | Pexp_field _ -> "field access expression"
    | Pexp_setfield _ -> "field set expression"
    | Pexp_array _ -> "array expression"
    | Pexp_ifthenelse (_, _, None) -> "if-then expression"
    | Pexp_ifthenelse (_, _, Some _) -> "if-then-else expression"
    | Pexp_sequence _ -> "sequencing ';' expression"
    | Pexp_while _ -> "while loop expression"
    | Pexp_for _ -> "for loop expression"
    | Pexp_constraint _ -> "type constraint ':' expression"
    | Pexp_coerce _ -> "type coercion ':>' expression"
    | Pexp_send _ -> "method send '#' expression"
    | Pexp_new _ -> "new-object expression"
    | Pexp_setinstvar _ -> "instance variable set '<-' expression"
    | Pexp_override _ -> "instance variable override '<{' ... '}>' expression"
    | Pexp_letmodule _ -> "let-module expression"
    | Pexp_letexception _ -> "let-exception expression"
    | Pexp_assert _ -> "assert expression"
    | Pexp_lazy _ -> "lazy expression"
    | Pexp_poly _ -> "polymorphic method body expression"
    | Pexp_object _ -> "object expression"
    | Pexp_newtype _ -> "type-parameterized expression"
    | Pexp_pack _ -> "first-class module expression"
    | Pexp_open _ -> "let-open '.' expression"
    | Pexp_letop _ -> "let-op expression"
    | Pexp_extension _ -> "extension point as an expression"
    | Pexp_unreachable -> "unreachable '.' expression"
    | Pexp_stack _ -> "stack expression"
  ;;

  let of_pattern_desc : Shim.Pattern_desc.t -> string = function
    | Ppat_any -> "wildcard '_' pattern"
    | Ppat_var _ -> "variable pattern"
    | Ppat_alias _ -> "alias 'as' pattern"
    | Ppat_constant (Pconst_char _) -> "character literal pattern"
    | Ppat_constant (Pconst_integer _) -> "integer literal pattern"
    | Ppat_constant (Pconst_string _) -> "string literal pattern"
    | Ppat_constant (Pconst_float _) -> "floating point literal pattern"
    | Ppat_interval _ -> "character interval '..' pattern"
    | Ppat_tuple _ -> "tuple pattern"
    | Ppat_unboxed_tuple _ -> "unboxed tuple pattern"
    | Ppat_construct _ -> "variant constructor pattern"
    | Ppat_variant _ -> "polymorphic variant constructor pattern"
    | Ppat_record (_, Closed) -> "closed record pattern"
    | Ppat_record (_, Open) -> "open record pattern"
    | Ppat_array _ -> "array pattern"
    | Ppat_or _ -> "or '|' pattern"
    | Ppat_constraint _ -> "type constraint ':' pattern"
    | Ppat_type _ -> "type '#' pattern"
    | Ppat_lazy _ -> "lazy pattern"
    | Ppat_unpack _ -> "first-class module pattern"
    | Ppat_exception _ -> "exception pattern"
    | Ppat_extension _ -> "extension point as a pattern"
    | Ppat_open _ -> "let-open '.' pattern"
  ;;
end

module Constructor_name = struct
  let of_core_type_desc : Shim.Core_type_desc.t -> string = function
    | Ptyp_var _ -> "Ptyp_var"
    | Ptyp_tuple _ -> "Ptyp_tuple"
    | Ptyp_constr _ -> "Ptyp_constr"
    | Ptyp_alias _ -> "Ptyp_alias"
    | Ptyp_variant _ -> "Ptyp_variant"
    | Ptyp_any -> "Ptyp_any"
    | Ptyp_arrow _ -> "Ptyp_arrow"
    | Ptyp_unboxed_tuple _ -> "Ptyp_unboxed_tuple"
    | Ptyp_object _ -> "Ptyp_object"
    | Ptyp_class _ -> "Ptyp_class"
    | Ptyp_poly _ -> "Ptyp_poly"
    | Ptyp_package _ -> "Ptyp_package"
    | Ptyp_extension _ -> "Ptyp_extension"
  ;;

  let of_expression_desc : Shim.Expression_desc.t -> string = function
    | Pexp_ident _ -> "Pexp_ident"
    | Pexp_constant _ -> "Pexp_constant"
    | Pexp_let _ -> "Pexp_let"
    | Pexp_function _ -> "Pexp_function"
    | Pexp_apply _ -> "Pexp_apply"
    | Pexp_match _ -> "Pexp_match"
    | Pexp_try _ -> "Pexp_try"
    | Pexp_tuple _ -> "Pexp_tuple"
    | Pexp_unboxed_tuple _ -> "Pexp_unboxed_tuple"
    | Pexp_construct _ -> "Pexp_construct"
    | Pexp_variant _ -> "Pexp_variant"
    | Pexp_record _ -> "Pexp_record"
    | Pexp_field _ -> "Pexp_field"
    | Pexp_setfield _ -> "Pexp_setfield"
    | Pexp_array _ -> "Pexp_array"
    | Pexp_ifthenelse _ -> "Pexp_ifthenelse"
    | Pexp_sequence _ -> "Pexp_sequence"
    | Pexp_while _ -> "Pexp_while"
    | Pexp_for _ -> "Pexp_for"
    | Pexp_constraint _ -> "Pexp_constraint"
    | Pexp_coerce _ -> "Pexp_coerce"
    | Pexp_send _ -> "Pexp_send"
    | Pexp_new _ -> "Pexp_new"
    | Pexp_setinstvar _ -> "Pexp_setinstvar"
    | Pexp_override _ -> "Pexp_override"
    | Pexp_letmodule _ -> "Pexp_letmodule"
    | Pexp_letexception _ -> "Pexp_letexception"
    | Pexp_assert _ -> "Pexp_assert"
    | Pexp_lazy _ -> "Pexp_lazy"
    | Pexp_poly _ -> "Pexp_poly"
    | Pexp_object _ -> "Pexp_object"
    | Pexp_newtype _ -> "Pexp_newtype"
    | Pexp_pack _ -> "Pexp_pack"
    | Pexp_open _ -> "Pexp_open"
    | Pexp_letop _ -> "Pexp_letop"
    | Pexp_extension _ -> "Pexp_extension"
    | Pexp_unreachable -> "Pexp_unreachable"
    | Pexp_stack _ -> "Pexp_stack"
  ;;

  let of_pattern_desc : Shim.Pattern_desc.t -> string = function
    | Ppat_any -> "Ppat_any"
    | Ppat_var _ -> "Ppat_var"
    | Ppat_alias _ -> "Ppat_alias"
    | Ppat_constant _ -> "Ppat_constant"
    | Ppat_interval _ -> "Ppat_interval"
    | Ppat_tuple _ -> "Ppat_tuple"
    | Ppat_unboxed_tuple _ -> "Ppat_unboxed_tuple"
    | Ppat_construct _ -> "Ppat_construct"
    | Ppat_variant _ -> "Ppat_variant"
    | Ppat_record _ -> "Ppat_record"
    | Ppat_array _ -> "Ppat_array"
    | Ppat_or _ -> "Ppat_or"
    | Ppat_constraint _ -> "Ppat_constraint"
    | Ppat_type _ -> "Ppat_type"
    | Ppat_lazy _ -> "Ppat_lazy"
    | Ppat_unpack _ -> "Ppat_unpack"
    | Ppat_exception _ -> "Ppat_exception"
    | Ppat_extension _ -> "Ppat_extension"
    | Ppat_open _ -> "Ppat_open"
  ;;
end
